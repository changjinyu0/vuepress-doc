(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{375:function(v,t,_){"use strict";_.r(t);var a=_(45),r=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"什么是闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包"}},[v._v("#")]),v._v(" 什么是闭包？")]),v._v(" "),_("p",[v._v("函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。闭包会一直占用内存空间，导致内存泄漏")]),v._v(" "),_("br"),v._v(" "),_("h3",{attrs:{id:"内存泄漏-vs-内存溢出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏-vs-内存溢出"}},[v._v("#")]),v._v(" 内存泄漏 VS 内存溢出")]),v._v(" "),_("p",[v._v("内存溢出：是指程序在申请内存时，没有足够的内存空间供其使用")]),v._v(" "),_("p",[v._v("内存泄漏：指申请的内存一直得不到释放，GC（垃圾回收机制）回收不了，过多的内存泄露会导致内存溢出")]),v._v(" "),_("br"),v._v(" "),_("h3",{attrs:{id:"怎样避免内存溢出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#怎样避免内存溢出"}},[v._v("#")]),v._v(" 怎样避免内存溢出？")]),v._v(" "),_("ul",[_("li",[v._v("尽量少使用全局变量，避免全局变量的泛滥，使用一个变量要先定义")]),v._v(" "),_("li",[v._v("使用全局变量保存大量数据时，确保用完以后设置为null")]),v._v(" "),_("li",[v._v("定时器不再需要时确保清除")]),v._v(" "),_("li",[v._v("清除绑定在DOM上的事件")]),v._v(" "),_("li",[v._v("用一个变量来引用DOM时，用完则脱离对这个DOM的引用，即置为null")]),v._v(" "),_("li",[v._v("在形成闭包的外部函数的最后，将在内部函数使用的变量赋值为null，避免多次调用外部函数，形成多个闭包，造成严重的内存泄漏")])]),v._v(" "),_("br"),v._v(" "),_("h3",{attrs:{id:"如何释放闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何释放闭包"}},[v._v("#")]),v._v(" 如何释放闭包？")]),v._v(" "),_("p",[v._v("因为闭包是引用导致的，所以只有当闭包函数被回收掉了，闭包内引用的变量才会被GC回收，可以直接把闭包函数直接置为null来促使GC回收")]),v._v(" "),_("br"),v._v(" "),_("h3",{attrs:{id:"闭包的使用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#闭包的使用场景"}},[v._v("#")]),v._v(" 闭包的使用场景")]),v._v(" "),_("ul",[_("li",[v._v("缓存数据")]),v._v(" "),_("li",[v._v("封装私有变量")]),v._v(" "),_("li",[v._v("模拟块级作用域")]),v._v(" "),_("li",[v._v("立即执行函数")]),v._v(" "),_("li",[v._v("防抖和节流、函数柯里化")])])])}),[],!1,null,null,null);t.default=r.exports}}]);